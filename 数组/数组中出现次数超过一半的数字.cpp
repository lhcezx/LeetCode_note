//  该方法时间复杂度为O(n)为最佳解法即"摩尔投票法"

//  假设我们要找的众数x提供的票数为1，非众数提供的票数为-1
//  初始化: 假设数组的第一个元素n1为众数, 若后面的元素和n1相等则vote++，反之vote--。当vote = 0的时候，分两种情况: 
//  1. n1真的是我们要找的众数x，那么在++--抵消的这些数字中，众数的数量占了抵消掉的数字的一半，因此这种情况对抵消掉的数组后面的部分来说，x即n1依然是众数，我们因此就缩小了考虑的数组区间(抵消掉的不再考虑)，问题变成了找剩下的数字组成的数组的众数。
//  2. n1不是我们要找的众数x，因为n1是我们假定的众数，那也就说明n1占了抵消的数组中一般的数量，另一半数量中的数字可能是我们要找的众数x，也可能是其他数字，因为都会被当作非众数对待，因此抵消掉的数字中，真正的众数x至多存在一半，至少存在0个。这样的情况下我们依然可以考虑剩下数字组成的的数组中，x依然为众数，因此同样缩小了区间范围。

//  如此循环直到区间大小为1，也就是只剩下一个数字就是众数本身，返回众数x


class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n = nums.size();
        int candidate = 0;                      //  我们要找的众数
        int counter = 0;
        for (int num: nums) {
            if (counter == 0) {                 //  当众数数量和其他数字抵消为0时，重选众数
                candidate = num;
                counter = 1;
            } else if (num == candidate) {      //  若为众数counter++，否则--
                counter++;
            } else if (num != candidate) {
                counter--;
            }
        }
        return candidate;
    }
};